package bindata

import (
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strconv"

	"github.com/blend/go-sdk/ex"
)

// Bundle is an assets bundle with associated options.
type Bundle struct {
	PackageName string
	Ignores     []*regexp.Regexp
}

// PackageNameOrDefault returns the package name or a default.
func (b *Bundle) PackageNameOrDefault() string {
	if b.PackageName != "" {
		return b.PackageName
	}
	return "static"
}

// Process processes a path with a given config.
func (b *Bundle) Process(output io.Writer, pc PathConfig) error {
	if err := b.writeHeader(output); err != nil {
		return err
	}
	if err := b.writeHelpers(output); err != nil {
		return err
	}
	if err := b.writeTypeFile(output); err != nil {
		return err
	}

	if err := b.writeAssetsHeader(output); err != nil {
		return err
	}
	if !pc.Recursive {
		f, err := b.readFile(pc.Path)
		if err != nil {
			return err
		}
		if err := b.writeAssetsFile(output, f); err != nil {
			return err
		}
	} else {
		if err := b.findFiles(pc.Path, b.Ignores, func(f *File) error {
			if err := b.writeAssetsFile(output, f); err != nil {
				return err
			}
			return nil
		}); err != nil {
			return err
		}
	}
	if err := b.writeAssetsFooter(output); err != nil {
		return err
	}
	return nil
}

func (b *Bundle) writeHeader(output io.Writer) error {
	if err := b.writeLines(output,
		"// Code generated by bindata.",
		"// DO NOT EDIT!",
		"",
	); err != nil {
		return err
	}
	if err := b.writeLines(output,
		"package "+b.PackageNameOrDefault(),
		"",
		"import (",
		"\t\"bytes\"",
		"\t\"compress/gzip\"",
		"\t\"io/ioutil\"",
		"\t\"os\"",
		"\t\"path/filepath\"",
		")",
		"",
	); err != nil {
		return err
	}
	return nil
}

func (b *Bundle) writeHelpers(output io.Writer) error {
	return b.writeLines(output,
		"// GetBinaryAsset returns a binary asset file or",
		"// os.ErrNotExist if it is not found.",
		"func GetBinaryAsset(path string) (*BinaryFile, error) {",
		"\tfile, ok := BinaryAssets[filepath.Clean(path)]",
		"\tif !ok {",
		"\t\treturn nil, os.ErrNotExist",
		"\t}",
		"\treturn file, nil",
		"}",
		"",
	)
}

func (b *Bundle) writeTypeFile(output io.Writer) error {
	return b.writeLines(output,
		"// BinaryFile represents a statically managed binary asset.",
		"type BinaryFile struct {",
		"\tName               string",
		"\tModTime            int64",
		"\tMD5                []byte",
		"\tCompressedContents []byte",
		"}",
		"",
		"// Contents returns the raw uncompressed content bytes",
		"func (bf *BinaryFile) Contents() ([]byte, error) {",
		"\tgzr, err := gzip.NewReader(bytes.NewReader(bf.CompressedContents))",
		"\tif err != nil {",
		"\t\treturn nil, err",
		"\t}",
		"\treturn ioutil.ReadAll(gzr)",
		"}",
		"",
		"// Decompress returns a decompression stream.",
		"func (bf *BinaryFile) Decompress() (*gzip.Reader, error) {",
		"\treturn gzip.NewReader(bytes.NewReader(bf.CompressedContents))",
		"}",
		"",
	)
}

func (b *Bundle) writeAssetsHeader(output io.Writer) error {
	if err := b.writeLines(output,
		"// BinaryAssets are a map from relative filepath to the binary file contents.",
		"// The binary file contents include the file name, md5, modtime, and binary contents.",
		"var BinaryAssets = map[string]*BinaryFile{",
	); err != nil {
		return err
	}

	return nil
}

func (b *Bundle) writeAssetsFile(output io.Writer, file *File) error {
	if _, err := io.WriteString(output, "\t\""+file.Name+"\": "); err != nil {
		return ex.New(err)
	}
	if err := b.writeAssetsFileContents(output, file); err != nil {
		return err
	}
	if _, err := io.WriteString(output, "\t},\n"); err != nil {
		return ex.New(err)
	}
	return nil
}

func (b *Bundle) writeAssetsFileContents(output io.Writer, file *File) error {
	if err := b.writeLines(output,
		"&BinaryFile{",
		"\t\tName:    \""+file.Name+"\",",
		"\t\tModTime: "+strconv.FormatInt(file.Modtime.Unix(), 10)+",",
		"\t\tMD5: []byte{",
	); err != nil {
		return err
	}
	if _, err := (&ByteWriter{Writer: output, Indent: []byte("\t\t\t")}).Write(file.Contents.MD5.Sum(nil)); err != nil {
		return err
	}
	if err := b.writeLines(output,
		"",
		"\t\t},",
		"\t\tCompressedContents: []byte{",
	); err != nil {
		return err
	}
	fileWriter := &ByteWriter{Writer: output, Indent: []byte("\t\t\t")}
	if _, err := file.Contents.WriteTo(fileWriter); err != nil {
		return err
	}
	if err := b.writeLines(output,
		"",
		"\t\t},",
	); err != nil {
		return err
	}
	return nil
}

func (b *Bundle) writeAssetsFooter(output io.Writer) error {
	if err := b.writeLines(output,
		"}",
		"",
	); err != nil {
		return err
	}
	return nil
}

func (b *Bundle) writeLines(output io.Writer, lines ...string) error {
	var err error
	for _, line := range lines {
		_, err = io.WriteString(output, line+"\n")
		if err != nil {
			return err
		}
	}
	return nil
}

// FindFiles traverses a root recursively, ignoring files that match the optional ignore
// expression, and calls the handler when it finds a file.
func (b *Bundle) findFiles(root string, ignores []*regexp.Regexp, handler func(*File) error) error {
	return filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		for _, ignore := range ignores {
			if ignore.MatchString(path) {
				if info.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}
		}
		if info.IsDir() {
			return nil
		}
		f, err := b.readFile(path)
		if err != nil {
			return err
		}
		if err = handler(f); err != nil {
			return err
		}
		return nil
	})
}

func (b Bundle) readFile(path string) (*File, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, ex.New(err)
	}
	stat, err := f.Stat()
	if err != nil {
		return nil, ex.New(err)
	}

	return &File{
		Name:     path,
		Modtime:  stat.ModTime(),
		Contents: NewFileCompressor(f),
	}, nil
}
