package bindata

import (
	"io"
	"regexp"
	"strconv"
)

// Bundle is an assets bundle with associated options.
type Bundle struct {
	PackageName string
	Ignores     []*regexp.Regexp
	Assets
}

// PackageNameOrDefault returns the package name or a default.
func (b *Bundle) PackageNameOrDefault() string {
	if b.PackageName != "" {
		return b.PackageName
	}
	return "static"
}

// Process processes a path with a given config.
func (b *Bundle) Process(pc PathConfig) error {
	if b.Assets == nil {
		b.Assets = make(Assets)
	}

	if !pc.Recursive {
		f, err := ReadFile(pc.Path)
		if err != nil {
			return err
		}
		b.Assets[pc.Path] = f
		return nil
	}

	return FindFiles(pc.Path, b.Ignores, func(f *File) {
		b.Assets[f.Name] = f
	})
}

// Write writes the full assets tree to a given file as a generated go file.
func (b *Bundle) Write(output io.Writer) error {
	if b.Assets == nil {
		b.Assets = make(Assets)
	}
	if err := b.writeHeader(output); err != nil {
		return err
	}
	if err := b.writeHelpers(output); err != nil {
		return err
	}
	if err := b.writeTypeFile(output); err != nil {
		return err
	}
	if err := b.writeAssets(output); err != nil {
		return err
	}
	return nil
}

func (b *Bundle) writeHeader(output io.Writer) error {
	if err := b.writeLines(output,
		"// Code generated by bindata.",
		"// sources:",
	); err != nil {
		return err
	}
	for _, path := range b.Assets.Paths() {
		if err := b.writeLines(output, "// "+path); err != nil {
			return err
		}
	}
	if err := b.writeLines(output,
		"// DO NOT EDIT!",
		"",
	); err != nil {
		return err
	}

	if err := b.writeLines(output,
		"package "+b.PackageNameOrDefault(),
		"",
		"import (",
		"\t\"os\"",
		"\t\"path/filepath\"",
		")",
		"",
	); err != nil {
		return err
	}
	return nil
}

func (b *Bundle) writeHelpers(output io.Writer) error {
	return b.writeLines(output,
		"",
		"// GetBinaryAsset returns a binary asset file or",
		"// os.ErrNotExist if it is not found.",
		"func GetBinaryAsset(path string) (*BinaryFile, error) {",
		"\tfile, ok := BinaryAssets[filepath.Clean(path)]",
		"\tif !ok {",
		"\t\treturn nil, os.ErrNotExist",
		"\t}",
		"\treturn file, nil",
		"}",
	)
}

func (b *Bundle) writeTypeFile(output io.Writer) error {
	return b.writeLines(output,
		"",
		"// BinaryFile represents a statically managed binary asset.",
		"type BinaryFile struct {",
		"\tName     string",
		"\tModTime  int64",
		"\tMD5      []byte",
		"\tContents []byte",
		"}",
	)
}

func (b *Bundle) writeAssets(output io.Writer) error {
	if err := b.writeLines(output,
		"",
		"// BinaryAssets are a map from relative filepath to the binary file contents.",
		"// The binary file contents include the file name, md5, modtime, and binary contents.",
		"var BinaryAssets = map[string]*BinaryFile{",
	); err != nil {
		return err
	}
	for _, key := range b.Assets.Paths() {
		io.WriteString(output, "\t\""+key+"\": ")
		if err := b.writeFile(output, b.Assets[key]); err != nil {
			return err
		}
		io.WriteString(output, "\t},\n")
	}
	if err := b.writeLines(output, "}"); err != nil {
		return err
	}
	return nil
}

func (b *Bundle) writeFile(output io.Writer, file *File) error {
	if err := b.writeLines(output,
		"&BinaryFile{",
		"\t\tName:    \""+file.Name+"\",",
		"\t\tModTime: "+strconv.FormatInt(file.Modtime.Unix(), 10)+",",
		"\t\tMD5: []byte{",
	); err != nil {
		return err
	}
	if _, err := (&ByteWriter{Writer: output, Indent: []byte("\t\t\t")}).Write(file.MD5); err != nil {
		return err
	}
	if err := b.writeLines(output,
		"",
		"\t\t},",
		"\t\tContents: []byte{",
	); err != nil {
		return err
	}
	if _, err := (&ByteWriter{Writer: output, Indent: []byte("\t\t\t")}).Write(file.Contents); err != nil {
		return err
	}
	if err := b.writeLines(output,
		"",
		"\t\t},",
	); err != nil {
		return err
	}
	return nil
}

func (b *Bundle) writeLines(output io.Writer, lines ...string) error {
	var err error
	for _, line := range lines {
		_, err = io.WriteString(output, line+"\n")
		if err != nil {
			return err
		}
	}
	return nil
}
